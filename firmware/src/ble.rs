//! BLE (Bluetooth Low Energy) module.
//!
//! Contains the GATT server definition, SoftDevice Controller builder,
//! MPSL background task, and the main advertising + connection loop.
//!
//! ## Architecture
//!
//! The Nordic nRF52840 BLE stack is split into two layers:
//!
//! - **MPSL** (Multi-Protocol Service Layer): manages radio timeslots and
//!   clocks.  Requires a dedicated background task ([`mpsl_task`]).
//! - **SDC** (SoftDevice Controller): the actual BLE link-layer controller,
//!   built on top of MPSL via [`build_sdc`].
//!
//! On top of SDC we run the `trouble-host` BLE host stack which provides
//! GATT server/client abstractions.
//!
//! ## Advertising payload
//!
//! Every advertising packet contains manufacturer-specific data (company ID
//! `0xFFFF` = "test/development") with 6 bytes:
//!
//! | Bytes | Content                        |
//! |-------|--------------------------------|
//! | 0–3   | Unix timestamp (u32 LE)        |
//! | 4–5   | Battery voltage in mV (u16 LE) |
//!
//! This lets the companion host read time and battery without connecting.
//! Advertising data is refreshed every 30 seconds.
//!
//! A BLE central can also **connect** to write a new Unix timestamp via the
//! GATT `TimeService` characteristic.

use crate::{BATTERY_MV, BUILD_TIMESTAMP, CURRENT_TIME};
use embassy_futures::join::join;
use embassy_futures::select::{Either, select};
use embassy_nrf::rng;
use embassy_time::{Duration, Timer};
use log::info;
use nrf_sdc::mpsl::MultiprotocolServiceLayer;
use nrf_sdc::{self as sdc};
use portable_atomic::Ordering;
use trouble_host::prelude::*;

// ---------------------------------------------------------------------------
// BLE stack sizing constants
// ---------------------------------------------------------------------------

/// Outgoing L2CAP buffers per connection.
const L2CAP_TXQ: u8 = 3;
/// Incoming L2CAP buffers per connection.
const L2CAP_RXQ: u8 = 3;
/// Maximum number of simultaneous BLE connections.
const CONNECTIONS_MAX: usize = 1;
/// L2CAP channels: one for signalling, one for ATT (attribute protocol).
const L2CAP_CHANNELS_MAX: usize = 2;

// ---------------------------------------------------------------------------
// GATT server definition (generated by trouble-host macros)
// ---------------------------------------------------------------------------

/// Top-level GATT server.  The `#[gatt_server]` macro generates the
/// attribute table and dispatch code automatically.
#[gatt_server]
struct Server {
    time_service: TimeService,
}

/// Custom GATT service that exposes a single read/write characteristic
/// holding the current Unix timestamp as a little-endian `u32`.
#[gatt_service(uuid = "a2d7a6e0-5e7b-4f1c-8a3d-b2c9f0e1d4a8")]
struct TimeService {
    /// Current Unix time in seconds.  Write to set the clock; read to
    /// retrieve the current value.
    #[characteristic(uuid = "a2d7a6e1-5e7b-4f1c-8a3d-b2c9f0e1d4a8", read, write)]
    unix_time: u32,
}

// ---------------------------------------------------------------------------
// Public functions
// ---------------------------------------------------------------------------

/// Build the Nordic SoftDevice Controller.
///
/// This configures the controller for a single peripheral connection
/// with advertising support.  `p` provides the PPI channels the SDC needs,
/// `rng` is the hardware random number generator, `mpsl` is the
/// already-initialised MPSL instance, and `mem` is a statically-allocated
/// buffer for the controller's internal state.
pub fn build_sdc<'d, const N: usize>(
    p: nrf_sdc::Peripherals<'d>,
    rng: &'d mut rng::Rng<'d, embassy_nrf::mode::Async>,
    mpsl: &'d MultiprotocolServiceLayer,
    mem: &'d mut sdc::Mem<N>,
) -> Result<nrf_sdc::SoftdeviceController<'d>, nrf_sdc::Error> {
    sdc::Builder::new()?
        .support_adv()
        .support_peripheral()
        .peripheral_count(1)?
        .buffer_cfg(
            DefaultPacketPool::MTU as u16,
            DefaultPacketPool::MTU as u16,
            L2CAP_TXQ,
            L2CAP_RXQ,
        )?
        .build(p, rng, mpsl, mem)
}

/// Background task that drives the MPSL event loop.
///
/// Must be spawned once at startup and left running for the entire lifetime
/// of the BLE stack.
#[embassy_executor::task]
pub async fn mpsl_task(mpsl: &'static MultiprotocolServiceLayer<'static>) -> ! {
    mpsl.run().await
}

/// Run the BLE host stack: sets up GATT, advertises, and handles connections.
///
/// This function never returns.  It:
/// 1. Creates the `trouble-host` BLE host stack on top of the SDC.
/// 2. Spawns two concurrent futures — the host **runner** (link-layer
///    housekeeping) and the **peripheral** loop (advertising + GATT).
/// 3. Refreshes advertising data every 30 s so the payload always carries
///    a recent timestamp and battery voltage.
/// 4. On connection, serves GATT read/write requests for the time
///    characteristic.
pub async fn run(sdc: nrf_sdc::SoftdeviceController<'_>) {
    // Static random BLE address (not derived from hardware ID).
    let address: Address = Address::random([0xff, 0x8f, 0x1a, 0x05, 0xe4, 0xff]);
    info!("BLE address = {:?}", address);

    // Allocate host-stack resources (packet pool, connection table, channels).
    let mut resources: HostResources<DefaultPacketPool, CONNECTIONS_MAX, L2CAP_CHANNELS_MAX> =
        HostResources::new();
    let stack = trouble_host::new(sdc, &mut resources).set_random_address(address);
    let Host {
        mut peripheral,
        mut runner,
        ..
    } = stack.build();

    // Create the GATT server with the device name "Voyager".
    let server = Server::new_with_config(GapConfig::Peripheral(PeripheralConfig {
        name: "Voyager",
        appearance: &appearance::UNKNOWN,
    }))
    .unwrap();

    info!(
        "Voyager BLE initialized (build timestamp: {})",
        BUILD_TIMESTAMP
    );

    // Future 1: host-stack housekeeping (must run continuously).
    let runner_fut = async {
        loop {
            if let Err(e) = runner.run().await {
                info!("[ble] runner error: {:?}", e);
            }
        }
    };

    // Future 2: advertising + connection handling.
    let peripheral_fut = async {
        // Handle to the unix_time characteristic so we can match GATT events.
        let unix_time = server.time_service.unix_time;

        let adv_params = AdvertisementParameters {
            interval_min: Duration::from_millis(1000),
            interval_max: Duration::from_millis(1000),
            ..Default::default()
        };

        loop {
            // --- Build advertising payload with fresh time + battery ---
            let ts = CURRENT_TIME.load(Ordering::Relaxed);
            let bat_mv = BATTERY_MV.load(Ordering::Relaxed) as u16;

            // 6-byte manufacturer data: [time_u32_le, bat_mv_u16_le]
            let mut payload = [0u8; 6];
            payload[0..4].copy_from_slice(&ts.to_le_bytes());
            payload[4..6].copy_from_slice(&bat_mv.to_le_bytes());

            let mut adv_data = [0; 31];
            let len = AdStructure::encode_slice(
                &[
                    AdStructure::Flags(LE_GENERAL_DISCOVERABLE | BR_EDR_NOT_SUPPORTED),
                    AdStructure::CompleteLocalName(b"Voyager"),
                    AdStructure::ManufacturerSpecificData {
                        company_identifier: 0xFFFF,
                        payload: &payload,
                    },
                ],
                &mut adv_data[..],
            )
            .unwrap();

            info!("[ble] advertising (time={}, bat={}mV)...", ts, bat_mv);

            // Start advertising (connectable + scannable undirected).
            let advertiser = match peripheral
                .advertise(
                    &adv_params,
                    Advertisement::ConnectableScannableUndirected {
                        adv_data: &adv_data[..len],
                        scan_data: &[],
                    },
                )
                .await
            {
                Ok(a) => a,
                Err(e) => {
                    info!("[ble] advertise error: {:?}", e);
                    Timer::after(Duration::from_secs(1)).await;
                    continue;
                }
            };

            // Wait for a connection, but time out after 30 s so we can
            // refresh the advertising payload with updated time/battery.
            let conn =
                match select(advertiser.accept(), Timer::after(Duration::from_secs(30))).await {
                    Either::Second(()) => {
                        // Timeout — restart advertising with fresh data.
                        continue;
                    }
                    Either::First(Err(e)) => {
                        info!("[ble] accept error: {:?}", e);
                        continue;
                    }
                    Either::First(Ok(c)) => match c.with_attribute_server(&server) {
                        Ok(c) => c,
                        Err(e) => {
                            info!("[ble] attribute server error: {:?}", e);
                            continue;
                        }
                    },
                };

            info!("[ble] connected");

            // --- Connection event loop ---
            loop {
                match conn.next().await {
                    GattConnectionEvent::Disconnected { reason } => {
                        info!("[ble] disconnected: {:?}", reason);
                        break;
                    }
                    GattConnectionEvent::Gatt { event } => {
                        match &event {
                            GattEvent::Write(event) => {
                                // Central wrote a new timestamp — update the clock.
                                if event.handle() == unix_time.handle {
                                    let data = event.data();
                                    if data.len() == 4 {
                                        let ts = u32::from_le_bytes([
                                            data[0], data[1], data[2], data[3],
                                        ]);
                                        CURRENT_TIME.store(ts, Ordering::Relaxed);
                                        info!("[ble] time set to {}", ts);
                                    }
                                }
                            }
                            GattEvent::Read(event) => {
                                // Central reading the timestamp — make sure
                                // the GATT value is up to date.
                                if event.handle() == unix_time.handle {
                                    let ts = CURRENT_TIME.load(Ordering::Relaxed);
                                    let _ = server.set(&unix_time, &ts);
                                    info!("[ble] time read: {}", ts);
                                }
                            }
                            _ => {}
                        }
                        // Send the GATT response back to the central.
                        match event.accept() {
                            Ok(reply) => reply.send().await,
                            Err(e) => info!("[gatt] error sending response: {:?}", e),
                        };
                    }
                    _ => {}
                }
            }
        }
    };

    // Run both futures concurrently (neither returns).
    join(runner_fut, peripheral_fut).await;
}
