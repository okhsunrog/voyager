//! Binary font format reader and embedded-graphics integration.
//!
//! This crate provides a `BitmapFont` type that can read the binary font format
//! generated by `font_generator` and render text using `embedded-graphics`.
//!
//! # Usage with const generics (compile-time size verification)
//!
//! ```rust,ignore
//! use font_generator::BitmapFont;
//!
//! // Font data embedded at compile time
//! static FONT_DATA: &[u8] = include_bytes!("../font.bin");
//!
//! // Load with compile-time size verification (panics if size mismatch)
//! let font: BitmapFont<16, 16> = BitmapFont::from_bytes_checked(FONT_DATA).unwrap();
//! ```
//!
//! # Build-time validation
//!
//! Add this to your embedded project's `build.rs`:
//!
//! ```rust,ignore
//! use font_generator::validate_font_file;
//!
//! fn main() {
//!     println!("cargo:rerun-if-changed=assets/font.bin");
//!     validate_font_file::<16, 16>("assets/font.bin")
//!         .expect("Font validation failed");
//! }
//! ```

use embedded_graphics::{
    Drawable, Pixel, draw_target::DrawTarget, geometry::Point, pixelcolor::BinaryColor,
};

/// Magic bytes for font format version 2 (with configurable size)
pub const MAGIC: &[u8; 4] = b"FNT2";

/// Header size in bytes
pub const HEADER_SIZE: usize = 16;

/// ASCII table size in bytes (128 entries * 4 bytes)
pub const ASCII_TABLE_SIZE: usize = 128 * 4;

/// Marker for missing glyphs
pub const MISSING_GLYPH: u32 = 0xFFFFFFFF;

/// Calculate bytes per row for a given width
pub const fn bytes_per_row(width: usize) -> usize {
    (width + 7) / 8
}

/// Calculate bytes per glyph for given dimensions
pub const fn bytes_per_glyph(width: usize, height: usize) -> usize {
    bytes_per_row(width) * height
}

/// Font validation error
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum FontError {
    /// Data too short to contain header
    TooShort,
    /// Invalid magic bytes (not a FNT2 file)
    InvalidMagic,
    /// Font dimensions don't match expected const generics
    SizeMismatch {
        expected_w: u8,
        expected_h: u8,
        actual_w: u8,
        actual_h: u8,
    },
    /// Data size doesn't match expected size based on glyph count
    InvalidDataSize,
    /// File I/O error (for validate_font_file)
    IoError(String),
}

impl core::fmt::Display for FontError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            FontError::TooShort => write!(f, "Font data too short"),
            FontError::InvalidMagic => write!(f, "Invalid magic bytes (expected FNT2)"),
            FontError::SizeMismatch {
                expected_w,
                expected_h,
                actual_w,
                actual_h,
            } => {
                write!(
                    f,
                    "Font size mismatch: expected {}x{}, got {}x{}",
                    expected_w, expected_h, actual_w, actual_h
                )
            }
            FontError::InvalidDataSize => write!(f, "Invalid data size"),
            FontError::IoError(msg) => write!(f, "I/O error: {}", msg),
        }
    }
}

#[cfg(feature = "std")]
impl std::error::Error for FontError {}

/// Information about a font file (for runtime inspection)
#[derive(Debug, Clone, Copy)]
pub struct FontInfo {
    pub width: u8,
    pub height: u8,
    pub glyph_count: u32,
    pub non_ascii_count: u32,
}

/// Read font info from binary data without loading the full font.
pub fn read_font_info(data: &[u8]) -> Result<FontInfo, FontError> {
    if data.len() < HEADER_SIZE {
        return Err(FontError::TooShort);
    }

    if &data[0..4] != MAGIC {
        return Err(FontError::InvalidMagic);
    }

    let width = data[4];
    let height = data[5];
    let glyph_count = u32::from_le_bytes([data[8], data[9], data[10], data[11]]);
    let non_ascii_count = u32::from_le_bytes([data[12], data[13], data[14], data[15]]);

    Ok(FontInfo {
        width,
        height,
        glyph_count,
        non_ascii_count,
    })
}

/// Validate a font file at build time.
///
/// Call this from your `build.rs` to ensure the font file is valid
/// and matches the expected dimensions.
///
/// # Example
///
/// ```rust,ignore
/// // In build.rs:
/// fn main() {
///     println!("cargo:rerun-if-changed=assets/font.bin");
///     font_generator::validate_font_file::<16, 16>("assets/font.bin")
///         .expect("Font validation failed");
/// }
/// ```
#[cfg(feature = "std")]
pub fn validate_font_file<const W: usize, const H: usize>(
    path: &str,
) -> Result<FontInfo, FontError> {
    let data = std::fs::read(path).map_err(|e| FontError::IoError(e.to_string()))?;
    validate_font_data::<W, H>(&data)
}

/// Validate font data matches expected dimensions.
pub fn validate_font_data<const W: usize, const H: usize>(
    data: &[u8],
) -> Result<FontInfo, FontError> {
    let info = read_font_info(data)?;

    // Check dimensions match
    if info.width as usize != W || info.height as usize != H {
        return Err(FontError::SizeMismatch {
            expected_w: W as u8,
            expected_h: H as u8,
            actual_w: info.width,
            actual_h: info.height,
        });
    }

    // Check data size
    let bpg = bytes_per_glyph(W, H);
    let non_ascii_table_size = info.non_ascii_count as usize * 8;
    let expected_size =
        HEADER_SIZE + ASCII_TABLE_SIZE + non_ascii_table_size + (info.glyph_count as usize * bpg);

    if data.len() < expected_size {
        return Err(FontError::InvalidDataSize);
    }

    Ok(info)
}

/// A bitmap font with compile-time known dimensions.
///
/// The const generics `W` and `H` specify the width and height of each glyph.
/// This allows for zero-cost abstractions and compile-time size verification.
pub struct BitmapFont<'a, const W: usize, const H: usize> {
    data: &'a [u8],
    glyph_count: u32,
    non_ascii_count: u32,
}

impl<'a, const W: usize, const H: usize> BitmapFont<'a, W, H> {
    /// Bytes per row for this font size
    pub const BYTES_PER_ROW: usize = bytes_per_row(W);

    /// Bytes per glyph for this font size
    pub const BYTES_PER_GLYPH: usize = bytes_per_glyph(W, H);

    /// Load a font from binary data with compile-time size verification.
    ///
    /// Returns an error if the font dimensions don't match `W` and `H`.
    pub fn from_bytes_checked(data: &'a [u8]) -> Result<Self, FontError> {
        let info = validate_font_data::<W, H>(data)?;

        Ok(Self {
            data,
            glyph_count: info.glyph_count,
            non_ascii_count: info.non_ascii_count,
        })
    }

    /// Load a font from binary data without size verification.
    ///
    /// # Safety
    ///
    /// The caller must ensure the font data has dimensions matching `W` and `H`.
    /// Using a font with mismatched dimensions will cause incorrect rendering
    /// or out-of-bounds access.
    pub unsafe fn from_bytes_unchecked(data: &'a [u8]) -> Option<Self> {
        if data.len() < HEADER_SIZE {
            return None;
        }

        if &data[0..4] != MAGIC {
            return None;
        }

        let glyph_count = u32::from_le_bytes([data[8], data[9], data[10], data[11]]);
        let non_ascii_count = u32::from_le_bytes([data[12], data[13], data[14], data[15]]);

        Some(Self {
            data,
            glyph_count,
            non_ascii_count,
        })
    }

    /// Get the number of glyphs in the font.
    pub fn glyph_count(&self) -> u32 {
        self.glyph_count
    }

    /// Get the width of each glyph.
    pub const fn width(&self) -> usize {
        W
    }

    /// Get the height of each glyph.
    pub const fn height(&self) -> usize {
        H
    }

    /// Get the glyph bitmap for a character.
    ///
    /// Returns `None` if the character is not in the font.
    pub fn get_glyph(&self, c: char) -> Option<&[u8]> {
        let offset = self.get_glyph_offset(c)?;
        let start = offset as usize;
        let end = start + Self::BYTES_PER_GLYPH;
        if end <= self.data.len() {
            Some(&self.data[start..end])
        } else {
            None
        }
    }

    fn get_glyph_offset(&self, c: char) -> Option<u32> {
        let cp = c as u32;

        if cp <= 0x7F {
            // ASCII: direct lookup
            let idx = HEADER_SIZE + (cp as usize * 4);
            let offset = u32::from_le_bytes([
                self.data[idx],
                self.data[idx + 1],
                self.data[idx + 2],
                self.data[idx + 3],
            ]);
            if offset == MISSING_GLYPH {
                None
            } else {
                Some(offset)
            }
        } else {
            // Non-ASCII: binary search
            self.binary_search_non_ascii(cp)
        }
    }

    fn binary_search_non_ascii(&self, codepoint: u32) -> Option<u32> {
        let table_start = HEADER_SIZE + ASCII_TABLE_SIZE;
        let count = self.non_ascii_count as usize;

        if count == 0 {
            return None;
        }

        let mut left = 0;
        let mut right = count;

        while left < right {
            let mid = left + (right - left) / 2;
            let entry_offset = table_start + mid * 8;

            let entry_cp = u32::from_le_bytes([
                self.data[entry_offset],
                self.data[entry_offset + 1],
                self.data[entry_offset + 2],
                self.data[entry_offset + 3],
            ]);

            if entry_cp == codepoint {
                let glyph_offset = u32::from_le_bytes([
                    self.data[entry_offset + 4],
                    self.data[entry_offset + 5],
                    self.data[entry_offset + 6],
                    self.data[entry_offset + 7],
                ]);
                return Some(glyph_offset);
            } else if entry_cp < codepoint {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        None
    }

    /// Check if the font contains a glyph for the given character.
    pub fn has_glyph(&self, c: char) -> bool {
        self.get_glyph_offset(c).is_some()
    }
}

/// A drawable text object using the bitmap font.
pub struct Text<'a, 'b, const W: usize, const H: usize> {
    text: &'a str,
    font: &'b BitmapFont<'b, W, H>,
    position: Point,
    color: BinaryColor,
}

impl<'a, 'b, const W: usize, const H: usize> Text<'a, 'b, W, H> {
    /// Create a new text drawable.
    pub fn new(text: &'a str, font: &'b BitmapFont<'b, W, H>, position: Point) -> Self {
        Self {
            text,
            font,
            position,
            color: BinaryColor::On,
        }
    }

    /// Set the text color.
    pub fn with_color(mut self, color: BinaryColor) -> Self {
        self.color = color;
        self
    }
}

impl<const W: usize, const H: usize> Drawable for Text<'_, '_, W, H> {
    type Color = BinaryColor;
    type Output = ();

    fn draw<D>(&self, target: &mut D) -> Result<Self::Output, D::Error>
    where
        D: DrawTarget<Color = Self::Color>,
    {
        let bpr = bytes_per_row(W);
        let mut x = self.position.x;
        let y = self.position.y;

        for c in self.text.chars() {
            if c == '\n' {
                continue;
            }

            if let Some(glyph_data) = self.font.get_glyph(c) {
                // Draw the glyph pixel by pixel
                for row in 0..H {
                    for byte_idx in 0..bpr {
                        let byte = glyph_data[row * bpr + byte_idx];
                        for bit in 0..8 {
                            let col = byte_idx * 8 + bit;
                            if col < W && byte & (1 << (7 - bit)) != 0 {
                                Pixel(Point::new(x + col as i32, y + row as i32), self.color)
                                    .draw(target)?;
                            }
                        }
                    }
                }
            }
            // Advance to next character position
            x += W as i32;
        }

        Ok(())
    }
}

/// A drawable text object with line wrapping and newline support.
pub struct WrappedText<'a, 'b, const W: usize, const H: usize> {
    text: &'a str,
    font: &'b BitmapFont<'b, W, H>,
    position: Point,
    color: BinaryColor,
    max_width: i32,
}

impl<'a, 'b, const W: usize, const H: usize> WrappedText<'a, 'b, W, H> {
    /// Create a new wrapped text drawable.
    pub fn new(
        text: &'a str,
        font: &'b BitmapFont<'b, W, H>,
        position: Point,
        max_width: i32,
    ) -> Self {
        Self {
            text,
            font,
            position,
            color: BinaryColor::On,
            max_width,
        }
    }

    /// Set the text color.
    pub fn with_color(mut self, color: BinaryColor) -> Self {
        self.color = color;
        self
    }
}

impl<const W: usize, const H: usize> Drawable for WrappedText<'_, '_, W, H> {
    type Color = BinaryColor;
    type Output = ();

    fn draw<D>(&self, target: &mut D) -> Result<Self::Output, D::Error>
    where
        D: DrawTarget<Color = Self::Color>,
    {
        let bpr = bytes_per_row(W);
        let mut x = self.position.x;
        let mut y = self.position.y;

        for c in self.text.chars() {
            if c == '\n' {
                x = self.position.x;
                y += H as i32;
                continue;
            }

            // Wrap if needed
            if x + W as i32 > self.position.x + self.max_width {
                x = self.position.x;
                y += H as i32;
            }

            if let Some(glyph_data) = self.font.get_glyph(c) {
                for row in 0..H {
                    for byte_idx in 0..bpr {
                        let byte = glyph_data[row * bpr + byte_idx];
                        for bit in 0..8 {
                            let col = byte_idx * 8 + bit;
                            if col < W && byte & (1 << (7 - bit)) != 0 {
                                Pixel(Point::new(x + col as i32, y + row as i32), self.color)
                                    .draw(target)?;
                            }
                        }
                    }
                }
            }
            x += W as i32;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_font_data() -> Vec<u8> {
        let bpg = bytes_per_glyph(16, 16);
        let mut data = vec![0u8; HEADER_SIZE + ASCII_TABLE_SIZE + bpg];

        // Magic
        data[0..4].copy_from_slice(MAGIC);
        // Width and height
        data[4] = 16;
        data[5] = 16;
        // Reserved
        data[6] = 0;
        data[7] = 0;
        // Glyph count
        data[8..12].copy_from_slice(&1u32.to_le_bytes());
        // Non-ASCII count
        data[12..16].copy_from_slice(&0u32.to_le_bytes());

        // Initialize all ASCII entries to MISSING_GLYPH
        for i in 0..128 {
            let idx = HEADER_SIZE + i * 4;
            data[idx..idx + 4].copy_from_slice(&MISSING_GLYPH.to_le_bytes());
        }

        // Set offset for 'A' (0x41)
        let a_offset = (HEADER_SIZE + ASCII_TABLE_SIZE) as u32;
        let idx = HEADER_SIZE + 0x41 * 4;
        data[idx..idx + 4].copy_from_slice(&a_offset.to_le_bytes());

        data
    }

    #[test]
    fn test_font_loading() {
        let data = create_test_font_data();
        let font: BitmapFont<16, 16> = BitmapFont::from_bytes_checked(&data).unwrap();
        assert_eq!(font.glyph_count(), 1);
        assert!(font.has_glyph('A'));
        assert!(!font.has_glyph('B'));
    }

    #[test]
    fn test_size_mismatch() {
        let data = create_test_font_data();
        let result: Result<BitmapFont<8, 8>, _> = BitmapFont::from_bytes_checked(&data);
        assert!(matches!(result, Err(FontError::SizeMismatch { .. })));
    }

    #[test]
    fn test_font_info() {
        let data = create_test_font_data();
        let info = read_font_info(&data).unwrap();
        assert_eq!(info.width, 16);
        assert_eq!(info.height, 16);
        assert_eq!(info.glyph_count, 1);
        assert_eq!(info.non_ascii_count, 0);
    }
}
